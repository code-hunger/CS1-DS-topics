# Обхождане на графи

## В ширина

- r ∈ V - начален връх
- adj = списък съседи
- eyes = {r} // тип опашка - слагаме накрая, взимаме първия
- dist = V → N
- dist[r] = 0

- while #eyes > 0:
    - w ← eyes
    - eyes ← eyes - { w }

    - visit w

    - ∀w' ∈ adj[w]:
        - if dist[w'] = ∞:
            - dist[w'] ← dist[w] + 1
            - eyes ← eyes ∪ { w' }

Коректност на пресметнатите дължини:
----

- Заб.: С *dist[w]* обозначаваме пресметната дължина от алгоритъма, а с *dist(w)* обозначаваме стойността на математическото понятие за дължината на най-късия път w↔r

- Ще док., че ∀w(dist[w] = dist(r, w)) с индукция по разстоянията dist(r, w) ∀w ∈ V
    - База: ∀x(dist(r,x) = 0) ⇒ x ∈ {r}. (ред 5.) dist[r] = 0 = dist(r,x) ⇒ Да.
    - Индуктивно предположение: ∀x (dist(r,x) ≤ k → dist(r, x) = dist[x])
        - Нека w ∈ V, dist(r, w) = k и w' му е съсед с непресметната дължина.
        - Със сигурност dist(r, w') ≥ k: в противен случай по предположение дължината му вече е пресметната.
        - Щом w' е съсед на w и dist(r,w') ≥ k ⇒ dist(r,w') = dist(r,w) + 1 = k + 1, и редът _dist[w'] ← dist[w] + 1_ прави точно това.

## В дълбочина

- r ∈ V - начален връх
- adj = списък съседи
- eyes = {r} // тип стек - вкарваме отзад, вадим отзад
- visited = {}

- while #eyes > 0:
    - w ← eyes
    - eyes ← eyes - { w }

    - visited[w] = T

    - ∀w' ∈ adj[w]:
        - if not visited:
            - eyes ← eyes ∪ { w' }

# Бойлерови пътища, цикли и обхождания

- Бойлеров път - всеки не непременно прост път с различни краища, съдържащ всяко ребро точно по веднъж
- Бойлеров цикъл - всеки не непременно прост цикъл, съдържащ всяко ребро точно по веднъж
- Бойлер граф - граф с бойлер цикъл

- Хамилтонов път - всеки прост път, минаващ през всички върхове
- Хамилтонов цикъл - всеки прост цикъл, минаващ през всички върхове
- Хамилтонов граф - граф, в който има хамилтонов цикъл

## Съществуване на бойлер цикъл в граф
- Мултиграф G=(V,E) има бойлер цикъл ↔ G е вързан ∧ (∀v ∈ V: d(v) е четно)
    - →) 1) G е очевидно вързан;
         2) Ако ∃v d(v) нечетно - няма бойлер цикъл, защото има неравен брой влизания и излизания
    - ←) Ще конструираме ойлеров цикъл:
        - За всяко ребро поддържаме флаг дали е обходено
        - c: цикълът, който строим
        - Докато има необходени ребра:
            - t := произволен връх от c с необходено ребро. (Задължително съществува: в противен случай c от G образува вързан компонент, а щом има още ребра, значи G не е свързан.)
            - c' := AlgB(G, t) // взимаме възможен цикъл от G с начало t. AlgB обновява и флаговете за обходеност на ребрата
            - c ← сливаме c и c':
                1. Ако c е празно - присвоявяме
                2. Ако c не е празно, то c и c' имат общ връх t, от който сме тръгнали.
        - Във всеки момент от алгоритмичния цикъл c е валиден цикъл, неповтарящ ребра. При излизане
            от цикъла няма необходени ребра. ⇒ c съдържа всички ребра, без да ги повтаря ⇒ c е
            ойлеров цикъл.
        - Връщаме c.

        Алгоритъм AlgB(G, t) за намиране на неповтарящ ребра цикъл в граф с начало връх t
        - c: пътят, който строим
        - c ← t
        - докато t е инцидентно с необходено ребро e=(t,v):
            - обозначаваме е - обходено
            - c ← е . v
            - t := v

        - При влизане в който и да е връх, алгоритмичният цикъл има изход от този връх, защото
          всички върхове са от четна степен, както и броят необходени ребра, инцидентни с него.
          Изключение прави първоначалният връх, от който на първия ход сме обозначили 1 ребро за
          обходено. ⇒ цикълът може да излезе единствено при достигане на първоначалния
          връх, след като са обходени всички инцидентни с него ребра. ⇒ c е цикъл, неповтарящ ребра.

        - Връщаме c.

@TODO Бойлер и Хамилтон обхождане
@TODO Теорема на Оре за Хамилтон граф
